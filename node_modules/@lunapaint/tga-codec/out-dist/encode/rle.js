"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeRunLengthEncoding = void 0;
const assert_js_1 = require("./assert.js");
function encodeRunLengthEncoding(ctx, data) {
    const bytesPerPixel = Math.ceil(ctx.bitDepth / 8);
    const bytesPerRlePacket = bytesPerPixel + 1;
    const result = new Uint8Array(ctx.image.width * ctx.image.height * bytesPerRlePacket);
    let resultIndex = 0;
    let currentPixelOffset = 0;
    let currentPixelCount = 1;
    let j = 0;
    let isRaw = false;
    let lastPacketPixelCount = 0;
    let lastPacketOffset = 0;
    let lastPacketWasRaw = false;
    for (let i = bytesPerPixel; i < data.length; i += bytesPerPixel) {
        let notEqual = false;
        for (j = 0; j < bytesPerPixel; j++) {
            notEqual || (notEqual = data[currentPixelOffset + j] !== data[i + j]);
        }
        if (notEqual) {
            while (currentPixelCount > 0) {
                isRaw = currentPixelCount === 1;
                if (lastPacketWasRaw && isRaw) {
                    lastPacketPixelCount = result[lastPacketOffset] & 127;
                    if (lastPacketPixelCount < 127) {
                        result[lastPacketOffset] = lastPacketPixelCount + 1;
                    }
                    else {
                        result[resultIndex] = (Math.min(currentPixelCount, 128) - 1);
                        lastPacketOffset = resultIndex;
                        resultIndex++;
                    }
                }
                else {
                    result[resultIndex] = (Math.min(currentPixelCount, 128) - 1) | (!isRaw ? 128 : 0);
                    lastPacketOffset = resultIndex;
                    resultIndex++;
                }
                for (j = 0; j < bytesPerPixel; j++) {
                    result[resultIndex + j] = data[currentPixelOffset + j];
                }
                resultIndex += bytesPerPixel;
                lastPacketWasRaw = isRaw;
                currentPixelCount -= 128;
            }
            currentPixelOffset = i;
            currentPixelCount = 1;
        }
        else {
            currentPixelCount++;
        }
    }
    while (currentPixelCount > 0) {
        isRaw = currentPixelCount === 1;
        if (lastPacketWasRaw && isRaw) {
            lastPacketPixelCount = result[lastPacketOffset] & 127;
            if (lastPacketPixelCount < 127) {
                result[lastPacketOffset] = lastPacketPixelCount + 1;
            }
            else {
                result[resultIndex] = (Math.min(currentPixelCount, 128) - 1);
                lastPacketOffset = resultIndex;
                resultIndex++;
            }
        }
        else {
            result[resultIndex] = (Math.min(currentPixelCount, 128) - 1) | (!isRaw ? 128 : 0);
            lastPacketOffset = resultIndex;
            resultIndex++;
        }
        for (j = 0; j < bytesPerPixel; j++) {
            result[resultIndex + j] = data[currentPixelOffset + j];
        }
        resultIndex += bytesPerPixel;
        currentPixelCount -= 128;
    }
    if (resultIndex - 1 > data.length) {
        (0, assert_js_1.handleWarning)(ctx, new assert_js_1.EncodeWarning('RLE encoded was used but it is larger than unencoded would be', -1));
    }
    return result.slice(0, resultIndex);
}
exports.encodeRunLengthEncoding = encodeRunLengthEncoding;
