"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyze = void 0;
const assert_js_1 = require("./assert.js");
function analyze(image, options = {}) {
    const warnings = [];
    const info = [];
    const partialCtx = {
        options,
        warnings
    };
    if (image.width > 65535) {
        throw new assert_js_1.EncodeError(`Image width is out of range (${image.width} > 65535)`, -1);
    }
    if (image.height > 65535) {
        throw new assert_js_1.EncodeError(`Image height is out of range (${image.height} > 65535)`, -1);
    }
    if (image.data.length !== image.width * image.height * 4) {
        throw new assert_js_1.EncodeError(`Provided image data length (${image.data.length}) is not expected length (${image.width * image.height * 4})`, Math.min(image.data.length, image.width * image.height * 4) - 1);
    }
    if (options.imageId && options.imageId.length > 255) {
        throw new assert_js_1.EncodeError(`Image ID length is out of range (${options.imageId.length} > 255)`, -1);
    }
    if (options.origin && (options.origin.x || 0) > 65535) {
        throw new assert_js_1.EncodeError(`X origin is out of range (${options.origin.x} > 65535)`, -1);
    }
    if (options.origin && (options.origin.y || 0) > 65535) {
        throw new assert_js_1.EncodeError(`Y origin is out of range (${options.origin.y} > 65535)`, -1);
    }
    if (options.screenOrigin === 1) {
        (0, assert_js_1.handleWarning)(partialCtx, new assert_js_1.EncodeWarning('This image is encoded using a bottom right screen origin, many image editors won\'t read this correctly', 17));
    }
    if (options.screenOrigin === 3) {
        (0, assert_js_1.handleWarning)(partialCtx, new assert_js_1.EncodeWarning('This image is encoded using a top right screen origin, many image editors won\'t read this correctly', 17));
    }
    if (options.bitDepth !== undefined && options.imageType === undefined || options.bitDepth === undefined && options.imageType !== undefined && options.imageType >= 0) {
        throw new assert_js_1.EncodeError('Bit depth and image type options must be used together', -1);
    }
    const imageTypeOrHint = options.imageType;
    let imageType;
    let imageTypeCompressionHint;
    if (imageTypeOrHint !== undefined) {
        if (imageTypeOrHint === -2 || imageTypeOrHint === -1) {
            imageTypeCompressionHint = imageTypeOrHint;
        }
        else {
            imageType = imageTypeOrHint;
        }
    }
    let bitDepth = options.bitDepth;
    let colorMap = undefined;
    if (bitDepth === 24) {
        if (detectTransparencyOnly(image)) {
            (0, assert_js_1.handleWarning)({ options, warnings }, new assert_js_1.EncodeWarning(`Cannot encode 24 bit image without data loss as it contains transparent colors`, 0));
        }
    }
    if (imageType === 9 || imageType === 1) {
        const result = detectIdealImageTypeAndBitDepth(image, imageTypeCompressionHint);
        if (!result.colorMap) {
            throw new assert_js_1.EncodeError(`Image has too many colors to encode using a color map`, -1);
        }
        colorMap = result.colorMap;
    }
    if (!bitDepth || imageTypeCompressionHint !== undefined) {
        const result = detectIdealImageTypeAndBitDepth(image, imageTypeCompressionHint);
        if (bitDepth && bitDepth < result.bitDepth) {
            throw new assert_js_1.EncodeError(`Image cannot be encoded using specified bit depth`, -1);
        }
        bitDepth = result.bitDepth;
        imageType = result.imageType;
        colorMap = result.colorMap;
    }
    if (!imageType) {
        throw new Error('No ImageType set');
    }
    return {
        bitDepth,
        imageType,
        colorMap,
        imageId: options.imageId || '',
        options,
        warnings,
        info,
        image
    };
}
exports.analyze = analyze;
function detectTransparencyOnly(image) {
    const pixelCount = image.width * image.height;
    const indexCount = pixelCount * 4;
    let hasTransparency = false;
    for (let i = 0; i < indexCount; i += 4) {
        hasTransparency || (hasTransparency = image.data[i + 3] < 255);
    }
    return hasTransparency;
}
function detectIdealImageTypeAndBitDepth(image, imageTypeCompressionHint) {
    const pixelCount = image.width * image.height;
    const indexCount = pixelCount * 4;
    let hasNon2BitTransparency = false;
    let hasTransparency = false;
    let cannotEncode5Bit = false;
    let hasColor = false;
    const uniqueColors = new Set();
    for (let i = 0; i < indexCount; i += 4) {
        hasNon2BitTransparency || (hasNon2BitTransparency = image.data[i + 3] > 0 && image.data[i + 3] < 255);
        hasTransparency || (hasTransparency = image.data[i + 3] < 255);
        if (!cannotEncode5Bit) {
            cannotEncode5Bit || (cannotEncode5Bit = !canEncode5Bit(image.data[i]) ||
                !canEncode5Bit(image.data[i + 1]) ||
                !canEncode5Bit(image.data[i + 2]) ||
                !canEncode5Bit(image.data[i + 3]));
        }
        if (!hasColor) {
            hasColor = (image.data[i] !== image.data[i + 1] ||
                image.data[i] !== image.data[i + 2]);
        }
        if (uniqueColors.size < 256) {
            uniqueColors.add((image.data[i] << 24) +
                (image.data[i + 1] << 16) +
                (image.data[i + 2] << 8) +
                (image.data[i + 3]));
        }
    }
    if (uniqueColors.size < 255) {
        const colorToIndexMap = new Map();
        let i = 0;
        for (const color of uniqueColors) {
            colorToIndexMap.set(color, i++);
        }
        let colorMap;
        if (!cannotEncode5Bit) {
            if (hasTransparency) {
                colorMap = { colorToIndexMap, bitDepth: 32 };
            }
            else {
                colorMap = { colorToIndexMap, bitDepth: 15 };
            }
        }
        else {
            if (hasTransparency) {
                colorMap = { colorToIndexMap, bitDepth: 32 };
            }
            else {
                colorMap = { colorToIndexMap, bitDepth: 24 };
            }
        }
        return {
            imageType: withCompressionHint(9, imageTypeCompressionHint),
            bitDepth: 8,
            colorMap
        };
    }
    if (!hasColor) {
        if (hasTransparency) {
            return { imageType: withCompressionHint(11, imageTypeCompressionHint), bitDepth: 16 };
        }
        return { imageType: withCompressionHint(11, imageTypeCompressionHint), bitDepth: 8 };
    }
    if (!cannotEncode5Bit) {
        if (hasTransparency) {
            if (hasNon2BitTransparency) {
                return { imageType: withCompressionHint(10, imageTypeCompressionHint), bitDepth: 32 };
            }
            return { imageType: withCompressionHint(10, imageTypeCompressionHint), bitDepth: 16 };
        }
        return { imageType: withCompressionHint(10, imageTypeCompressionHint), bitDepth: 15 };
    }
    if (hasTransparency) {
        return { imageType: withCompressionHint(10, imageTypeCompressionHint), bitDepth: 32 };
    }
    return { imageType: withCompressionHint(10, imageTypeCompressionHint), bitDepth: 24 };
}
function withCompressionHint(imageType, hint) {
    if (hint === undefined) {
        return imageType;
    }
    switch (imageType) {
        case 1:
        case 9:
            return hint === -2 ? 9 : 1;
        case 2:
        case 10:
            return hint === -2 ? 10 : 2;
        case 3:
        case 11:
            return hint === -2 ? 11 : 3;
    }
}
function canEncode5Bit(value) {
    return ((value >> 5) & 7) === (value & 7);
}
