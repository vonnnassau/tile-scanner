"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeTga = void 0;
const analyze_js_1 = require("./analyze.js");
const byteStream_js_1 = require("./byteStream.js");
const rle_js_1 = require("./rle.js");
async function encodeTga(image, options = {}) {
    const ctx = (0, analyze_js_1.analyze)(image, options);
    const sections = [];
    sections.push(writeTgaHeader(ctx));
    if (ctx.imageId.length > 0) {
        sections.push(writeImageId(ctx));
    }
    if (ctx.colorMap) {
        sections.push(writeColorMap(ctx));
    }
    sections.push(writeImageData(ctx));
    const totalLength = sections.reduce((p, c) => p + c.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const s of sections) {
        result.set(s, offset);
        offset += s.length;
    }
    return {
        data: result,
        warnings: ctx.warnings,
        info: ctx.info
    };
}
exports.encodeTga = encodeTga;
function writeTgaHeader(ctx) {
    const stream = new byteStream_js_1.ByteStream(18, true);
    stream.writeUint8(ctx.imageId.length);
    stream.writeUint8(ctx.colorMap ? 1 : 0);
    stream.writeUint8(ctx.imageType);
    stream.writeUint16(0);
    stream.writeUint16(ctx.colorMap?.colorToIndexMap.size ?? 0);
    stream.writeUint8(ctx.colorMap?.bitDepth ?? 0);
    stream.writeUint16(ctx.options.origin?.x || 0);
    stream.writeUint16(ctx.options.origin?.y || 0);
    stream.writeUint16(ctx.image.width);
    stream.writeUint16(ctx.image.height);
    stream.writeUint8(ctx.bitDepth);
    let alphaBits = 0;
    if (ctx.bitDepth === 32) {
        alphaBits = 8;
    }
    const imageDescriptor = ((alphaBits & 15) |
        ((ctx.options.screenOrigin ?? 0) << 4 & 48));
    stream.writeUint8(imageDescriptor);
    stream.assertAtEnd();
    return stream.array;
}
function writeImageId(ctx) {
    const stream = new byteStream_js_1.ByteStream(ctx.imageId.length, true);
    for (let i = 0; i < ctx.imageId.length; i++) {
        stream.writeUint8(ctx.imageId.charCodeAt(i));
    }
    stream.assertAtEnd();
    return stream.array;
}
function writeColorMap(ctx) {
    const cm = ctx.colorMap;
    if (!cm) {
        throw new Error('Cannot write color map undefined');
    }
    const bitsPerPixel = Math.ceil(cm.bitDepth / 8);
    const stream = new byteStream_js_1.ByteStream(cm.colorToIndexMap.size * bitsPerPixel, true);
    let writePixel;
    switch (cm.bitDepth) {
        case 15:
            writePixel = writePixel15Bit;
            break;
        case 16:
            writePixel = writePixel16Bit;
            break;
        case 24:
            writePixel = writePixel24Bit;
            break;
        case 32:
            writePixel = writePixel32Bit;
            break;
        default:
            throw new Error(`Unsupported bit depth for color map "${cm.bitDepth}"`);
    }
    const sortedColors = Array.from(cm.colorToIndexMap.entries()).sort((a, b) => a[1] - b[1]).map(e => e[0]);
    for (const color of sortedColors) {
        writePixel(stream, new Uint8Array([
            (color >> 24) & 0xFF,
            (color >> 16) & 0xFF,
            (color >> 8) & 0xFF,
            (color) & 0xFF,
        ]), 0);
    }
    stream.assertAtEnd();
    return stream.array;
}
function writeImageData(ctx) {
    const bytesPerPixel = Math.ceil(ctx.bitDepth / 8);
    const stream = new byteStream_js_1.ByteStream(ctx.image.width * ctx.image.height * bytesPerPixel, true);
    let imageOffset = 0;
    let writePixel;
    if (ctx.colorMap) {
        const cm = ctx.colorMap;
        writePixel = (stream, imageData, imageOffset) => {
            const colorIndex = cm.colorToIndexMap.get((imageData[imageOffset] << 24) +
                (imageData[imageOffset + 1] << 16) +
                (imageData[imageOffset + 2] << 8) +
                (imageData[imageOffset + 3]));
            stream.writeUint8(colorIndex);
        };
    }
    else {
        switch (ctx.bitDepth) {
            case 8:
                if (ctx.imageType === 3 || ctx.imageType === 11) {
                    writePixel = writePixel8BitGreyscale;
                }
                else {
                    throw new Error(`Unsupported image type (${ctx.imageType}) with bit depth (${ctx.bitDepth})`);
                }
                break;
            case 15:
                writePixel = writePixel15Bit;
                break;
            case 16:
                if (ctx.imageType === 3 || ctx.imageType === 11) {
                    writePixel = writePixel16BitGreyscale;
                }
                else {
                    writePixel = writePixel16Bit;
                }
                break;
            case 24:
                writePixel = writePixel24Bit;
                break;
            case 32:
                writePixel = writePixel32Bit;
                break;
            default:
                throw new Error('NYI');
        }
    }
    switch (ctx.options.screenOrigin ?? 0) {
        case 0:
            for (let y = ctx.image.height - 1; y >= 0; y--) {
                imageOffset = ctx.image.width * y * 4;
                for (let x = 0; x < ctx.image.width; x++) {
                    writePixel(stream, ctx.image.data, imageOffset);
                    imageOffset += 4;
                }
            }
            break;
        case 1:
            for (let y = ctx.image.height - 1; y >= 0; y--) {
                imageOffset = (ctx.image.width * y + (ctx.image.width - 1)) * 4;
                for (let x = 0; x < ctx.image.width; x++) {
                    writePixel(stream, ctx.image.data, imageOffset);
                    imageOffset -= 4;
                }
            }
            break;
        case 2:
            for (let y = 0; y < ctx.image.height; y++) {
                imageOffset = ctx.image.width * y * 4;
                for (let x = 0; x < ctx.image.width; x++) {
                    writePixel(stream, ctx.image.data, imageOffset);
                    imageOffset += 4;
                }
            }
            break;
        case 3:
            for (let y = 0; y < ctx.image.height; y++) {
                imageOffset = (ctx.image.width * y + (ctx.image.width - 1)) * 4;
                for (let x = 0; x < ctx.image.width; x++) {
                    writePixel(stream, ctx.image.data, imageOffset);
                    imageOffset -= 4;
                }
            }
            break;
    }
    stream.assertAtEnd();
    if (ctx.imageType & 8) {
        return (0, rle_js_1.encodeRunLengthEncoding)(ctx, stream.array);
    }
    return stream.array;
}
function writePixel8BitGreyscale(stream, imageData, imageOffset) {
    stream.writeUint8(imageData[imageOffset]);
}
function writePixel15Bit(stream, imageData, imageOffset) {
    stream.writeUint16((((imageData[imageOffset + 0] >> 3) & 0x1f) << 10) |
        (((imageData[imageOffset + 1] >> 3) & 0x1f) << 5) |
        (((imageData[imageOffset + 2] >> 3) & 0x1f) << 0));
}
function writePixel16Bit(stream, imageData, imageOffset) {
    stream.writeUint16((((imageData[imageOffset + 0] >> 3) & 0x1f) << 10) |
        (((imageData[imageOffset + 1] >> 3) & 0x1f) << 5) |
        (((imageData[imageOffset + 2] >> 3) & 0x1f) << 0) |
        (imageData[imageOffset + 3] === 255 ? (1 << 15) : 0));
}
function writePixel16BitGreyscale(stream, imageData, imageOffset) {
    stream.writeUint8(imageData[imageOffset]);
    stream.writeUint8(imageData[imageOffset + 3]);
}
function writePixel24Bit(stream, imageData, imageOffset) {
    stream.writeUint8(imageData[imageOffset + 2]);
    stream.writeUint8(imageData[imageOffset + 1]);
    stream.writeUint8(imageData[imageOffset + 0]);
}
function writePixel32Bit(stream, imageData, imageOffset) {
    stream.writeUint8(imageData[imageOffset + 2]);
    stream.writeUint8(imageData[imageOffset + 1]);
    stream.writeUint8(imageData[imageOffset + 0]);
    stream.writeUint8(imageData[imageOffset + 3]);
}
